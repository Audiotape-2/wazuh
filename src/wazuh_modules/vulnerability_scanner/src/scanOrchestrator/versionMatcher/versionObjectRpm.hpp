/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * December 14, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _VERSION_OBJECT_RPM_HPP
#define _VERSION_OBJECT_RPM_HPP

#include "iVersionObjectInterface.hpp"
#include "stringHelper.h"
#include <cctype>
#include <cstring>
#include <iostream>
#include <limits.h>
#include <memory>
#include <regex>
#include <string>

/**
 * @brief Rpm data struct.
 *
 */
struct Rpm
{
    uint32_t epoch;
    std::string version;
    std::string release;
};

auto constexpr LEFT_IS_NEWER = 1;
auto constexpr RIGHT_IS_NEWER = -1;
auto constexpr LEFT_EQ_RIGHT = 0;

/**
 * @brief VersionObjectRpm class.
 *
 */
class VersionObjectRpm final : public IVersionObject
{
private:
    static std::regex m_parserRegex;
    uint32_t m_epoch;
    std::string m_version;
    std::string m_release;

    /**
     * @brief Removes all leading characters from a vector of characters that are not alphanumeric and not a tilde (~).
     *
     * This function iterates over the beginning of a vector of characters. It removes any leading characters that do
     * not meet the criteria of being alphanumeric (letters or digits) or the tilde character (~). The operation stops
     * as soon as it encounters a character that meets the criteria or when there are no characters left in the vector.
     *
     * @param charList A reference to a vector of characters (`std::vector<char>`) that will be modified in place.
     * Leading characters that are not alphanumeric and not a tilde (~) will be removed.
     */
    void removeNonAlnumAndNonTilde(std::vector<char>& charList) const
    {
        while (!charList.empty() && !std::isalnum(charList.front()) && charList.front() != '~')
        {
            charList.erase(charList.begin());
        }
    }

    /**
     * @brief Trims any leading zeros from provided character lists.
     *
     * Iterates over each list in the collection of character lists. For each list, it checks the beginning
     * for characters that are '0's and removes any such leading zeros. This operation modifies the passed
     * lists in place, potentially altering their content by removing all leading '0' characters until a
     * non-'0' character or the end of the list is reached.
     *
     * @param char_lists A reference to a vector of characters (`std::vector<char>&`) from which leading '0's will be
     * removed if present.
     */
    void trimZeros(std::vector<char>& charList) const
    {
        while (!charList.empty() && charList.front() == '0')
        {
            charList.erase(charList.begin());
        }
    }

    /**
     * @brief Pops consecutive digits from the front of a character list and returns them.
     *
     * This function iterates over the beginning of a provided character list. If the front
     * character is a digit, it is removed from the list and added to a new list of digits.
     * This process continues until a non-digit character is encountered or the list is empty.
     * The function modifies the original character list by removing the leading digits and
     * returns a new list containing all the consecutive digits that were at the front of the
     * original list.
     *
     * @param charList A reference to a vector of characters (`std::vector<char>&`). The function
     *                 modifies this list by removing leading digit characters.
     * @return A vector of characters (`std::vector<char>`) containing all the consecutive digits
     *         that were removed from the front of the original list. This vector does not include
     *         any non-digit characters.
     */
    std::vector<char> popDigits(std::vector<char>& charList) const
    {
        std::vector<char> digits;
        while (!charList.empty() && std::isdigit(static_cast<unsigned char>(charList.front())))
        {
            digits.push_back(charList.front());
            charList.erase(charList.begin());
        }
        return digits;
    }

    /**
     * @brief Removes and returns all consecutive letters from the start of a character list.
     *
     * This function iterates over the beginning of the provided character list. If the front
     * character is a letter, it is removed from the list and added to a new list of letters.
     * This process continues until a non-letter character is encountered or the list becomes empty.
     * The function modifies the original character list by removing the leading letters and
     * returns a new list containing all the consecutive letters that were at the front of the
     * original list.
     *
     * @param charList A reference to a vector of characters (`std::vector<char>&`). The function
     *                 modifies this list by removing leading letter characters.
     * @return A vector of characters (`std::vector<char>`) containing all the consecutive letters
     *         that were removed from the front of the original list. This vector does not include
     *         any non-letter characters.
     */
    std::vector<char> popLetters(std::vector<char>& charList) const
    {
        std::vector<char> letters;
        while (!charList.empty() && std::isdigit(static_cast<unsigned char>(charList.front())))
        {
            letters.push_back(charList.front());
            charList.erase(charList.begin());
        }
        return letters;
    }

    /**
     * @brief Compares two blocks of characters to determine which is newer.
     *
     * This function compares two blocks of characters, which should be either all digits or all letters, as returned
     * by the `popDigits` or `popLetters` functions. The comparison logic mirrors that used by RPM version comparison.
     * If the blocks consist of digits, any leading zeros are trimmed from both blocks. The block with greater length
     * after trimming is considered larger. If the blocks are of the same length (after trimming for digit blocks), or
     * if they consist of letters, the blocks are compared as strings.
     *
     * The comparison for equality checks if the string representations of the blocks are equal. If not, the blocks are
     * compared lexicographically to determine which is greater. The function defines "newer" based on the comparison:
     * a block is newer if it is considered larger in the comparison.
     *
     * @param blockA The first block of characters for comparison, must be either all digits or all letters.
     * @param blockB The second block of characters for comparison, must match the character type (digits or letters)
     *               of `blockA`.
     * @return Returns `LEFT_IS_NEWER` if `blockA` is considered newer, `RIGHT_IS_NEWER` if `blockB` is newer, or `0`
     *         if the blocks are considered equal.
     *
     * Note: `LEFT_IS_NEWER` and `RIGHT_IS_NEWER` should be defined constants indicating the comparison result,
     * typically 1 and -1, respectively.
     */
    int compareBlocks(std::vector<char>& blockA, std::vector<char>& blockB) const
    {
        if (std::isdigit(static_cast<unsigned char>(blockA.front())))
        {
            trimZeros(blockA);
            trimZeros(blockB);

            if (blockA.size() != blockB.size())
            {
                return blockA.size() > blockB.size() ? LEFT_IS_NEWER : RIGHT_IS_NEWER;
            }
        }

        // For blocks of the same length or non-numeric blocks, compare as strings
        std::string strA(blockA.begin(), blockA.end()), strB(blockB.begin(), blockB.end());

        if (strA == strB)
        {
            return LEFT_EQ_RIGHT;
        }
        else
        {
            return strA < strB ? RIGHT_IS_NEWER : LEFT_IS_NEWER;
        }
    }

    /**
     * @brief Compares the first block from two character lists to determine which is newer.
     *
     * This function examines the first character of the `leftSide` character list. If it begins with a digit,
     * the `popDigits` function is called on both lists to extract blocks of all consecutive digits at the start
     * of each list. If `rightSide` begins with a letter (indicated by an empty block returned for `rightSide`),
     * `leftSide` is considered newer. Conversely, if `rightSide` returns a block of nonzero length, the blocks
     * are compared using `compareBlocks`.
     *
     * If `leftSide` begins with a letter, the `popLetters` function is called on both lists to extract blocks of
     * all consecutive letters at the start of each list. If `rightSide` starts with a digit (indicated by an empty
     * block for `rightSide`), then `rightSide` is considered newer. If `rightSide` returns a block of nonzero length,
     * blocks from `leftSide` and `rightSide` are compared using `compareBlocks`.
     *
     * @param leftSide A constant reference to a vector of characters derived from a version string.
     * @param rightSide A constant reference to a vector of characters derived from a version string.
     * @return Returns LEFT_IS_NEWER if `leftSide` is newer, LEFT_EQ_RIGHT if the versions are equal, or RIGHT_IS_NEWER
     * if `rightSide` is newer.
     */
    int getBlockResult(std::vector<char>& leftSide, std::vector<char>& rightSide) const
    {
        bool firstIsDigit = std::isdigit(static_cast<unsigned char>(leftSide.front()));
        std::vector<char> blockA, blockB;

        int returnIfNotB = firstIsDigit ? LEFT_IS_NEWER : RIGHT_IS_NEWER;

        if (firstIsDigit)
        {
            blockA = popDigits(leftSide);
            blockB = popDigits(rightSide);
        }
        else
        {
            blockA = popLetters(leftSide);
            blockB = popLetters(rightSide);
        }

        if (blockB.empty())
        {
            return returnIfNotB;
        }

        return compareBlocks(blockA, blockB);
    }

    /**
     * @brief Compares two version strings following RPM version comparison rules.
     *
     * This function compares two version strings to determine which version is newer, using comparison rules that
     * mirror those used by RPM. This ensures compatibility with standard RPM package versioning. The comparison process
     * involves several steps to accurately compare version strings that may include alphanumeric characters and tildes
     * (~).
     *
     * The process begins by checking for string equality. If both version strings are identical, they are considered
     * equal. If not, each string is converted into a list of characters for a detailed comparison.
     *
     * The comparison involves the following steps:
     * - First, any leading characters that are not alphanumeric and not tildes (~) are trimmed from both character
     * lists.
     * - Next, leading tildes (~) are removed. The presence of a tilde at the beginning of a version indicates that the
     * version should be considered older than versions without a tilde, even if numerically larger. Therefore, if one
     * version starts with a tilde and the other does not, the version without the tilde is considered newer.
     * - The comparison then proceeds by popping and comparing consecutive blocks of digits or letters from the start of
     * each list. If a difference is found, the comparison result of these blocks is returned immediately.
     * - If all characters are compared without finding a difference, the comparison concludes by examining the lengths
     * of any remaining characters in the lists. A version with remaining characters is considered newer, unless those
     * characters begin with a tilde, in which case it is considered older. This step accounts for scenarios where one
     * version string has been entirely consumed, leaving characters in the other, such as when comparing "1.05b" to
     * "1.05".
     *
     * @param leftVer The left-hand side version string to compare.
     * @param rightVer The right-hand side version string to compare.
     * @return Returns 1 if `leftVer` is considered newer, -1 if `rightVer` is newer, or 0 if both versions are
     * considered equal.
     */
    int compareVersions(const std::string& leftVer, const std::string& rightVer) const
    {
        if (leftVer == rightVer)
        {
            return LEFT_EQ_RIGHT;
        }

        std::vector<char> leftSide(leftVer.begin(), leftVer.end());
        std::vector<char> rightSide(rightVer.begin(), rightVer.end());

        while (!leftSide.empty() && !rightSide.empty())
        {
            removeNonAlnumAndNonTilde(leftSide);
            removeNonAlnumAndNonTilde(rightSide);

            if (leftSide.front() == '~' && rightSide.front() == '~')
            {
                leftSide.erase(leftSide.begin());
                rightSide.erase(rightSide.begin());
                continue;
            }
            else if (leftSide.front() == '~')
            {
                return RIGHT_IS_NEWER;
            }
            else if (rightSide.front() == '~')
            {
                return LEFT_IS_NEWER;
            }

            if (leftSide.empty() || rightSide.empty())
            {
                break;
            }

            int blockResult = getBlockResult(leftSide, rightSide);

            if (blockResult != LEFT_EQ_RIGHT)
            {
                return blockResult;
            }
        }

        if (leftSide.size() == rightSide.size())
        {
            return LEFT_EQ_RIGHT;
        }
        else
        {
            if (leftSide.size() > rightSide.size())
            {
                return leftSide.front() == '~' ? RIGHT_IS_NEWER : LEFT_IS_NEWER;
            }
            else
            {
                return rightSide.front() == '~' ? LEFT_IS_NEWER : RIGHT_IS_NEWER;
            }
        }
    }

    /**
     *  Compare two EVR values to determine which is newer
     *
     *  This method compares the epoch, version, and release of the
     *  provided package strings, assuming that epoch is 0 if not provided.
     *  Comparison is performed on the epoch, then the version, and then
     *  the release. If at any point a non-equality is found, the result is
     *  returned without any remaining comparisons being performed (e.g. if
     *  the epochs of the packages differ, the versions are releases are
     *  not compared).
     *
     * @see rpmdev-vercmp(1)
     *
     * @param rRpmVersion The second RPM version.
     *
     * @retval 0 If a and b are equal.
     * @retval <0 If a is smaller than b.
     * @retval >0 If a is greater than b.
     */
    int compareRpmVersion(const uint32_t rEpoch, const std::string& rVersion, const std::string& rRelease) const
    {
        // Compare epochs
        if (m_epoch != rEpoch)
        {
            return m_epoch < rEpoch ? RIGHT_IS_NEWER : LEFT_IS_NEWER;
        }

        // If epochs are equal, compare versions.
        auto verComp = compareVersions(m_version, rVersion);

        if (verComp != LEFT_EQ_RIGHT)
        {
            return verComp;
        }

        // If versions are equal, compare releases.
        return compareVersions(m_release, rRelease);
    }

public:
    /**
     * @brief Static method to match a version string to a Rpm object.
     *
     * @param version version string to match.
     * @param output Rpm object to store the result.
     * @return true/false according to match condition.
     */
    static bool match(const std::string& version, Rpm& output)
    {
        std::smatch parserMatches;
        if ((std::regex_search(version, parserMatches, m_parserRegex)) && (parserMatches.size() == 4))
        {
            output.epoch = parserMatches[1].str().empty() ? 0 : std::stoi(parserMatches[1].str());
            output.version = parserMatches[2].str();
            output.release = parserMatches[3].str();
            return true;
        }
        else
        {
            return false;
        }
    }
    /**
     * @brief Constructor.
     *
     * @param version version SemVer object.
     */
    explicit VersionObjectRpm(const Rpm& version)
        : m_epoch(version.epoch)
        , m_version(version.version)
        , m_release(version.release)
    {
    }
    // LCOV_EXCL_START
    ~VersionObjectRpm() override = default;
    // LCOV_EXCL_STOP

    /**
     * @brief Returns the VersionObjectType of this class.
     *
     * @return VersionObjectType.
     */
    VersionObjectType getType() override
    {
        return VersionObjectType::RPM;
    }

    /**
     * @brief Comparison operator ==.
     *
     * @param b comparison rhs object.
     * @return true/false according to equality condition.
     */
    bool operator==(const IVersionObject& b) const override
    {
        const auto* pB = dynamic_cast<const VersionObjectRpm*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }

        return compareRpmVersion(pB->m_epoch, pB->m_version, pB->m_release) == 0;
    }

    /**
     * @brief Comparison operator <.
     *
     * @param b comparison rhs object.
     * @return true/false according to less than condition.
     */
    bool operator<(const IVersionObject& b) const override
    {
        const auto* pB = dynamic_cast<const VersionObjectRpm*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        return compareRpmVersion(pB->m_epoch, pB->m_version, pB->m_release) == -1;
    }
};

#endif // _VERSION_OBJECT_RPM_HPP
