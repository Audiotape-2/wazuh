/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * December 14, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _VERSION_OBJECT_RPM_HPP
#define _VERSION_OBJECT_RPM_HPP

#include "iVersionObjectInterface.hpp"
#include "stringHelper.h"
#include <cctype>
#include <cstring>
#include <iostream>
#include <limits.h>
#include <memory>
#include <regex>
#include <string>

/**
 * @brief Rpm data struct.
 *
 */
struct Rpm
{
    uint32_t epoch;      ///< Epoch value.
    std::string version; ///< Version value.
    std::string release; ///< Release value.
};

auto constexpr LEFT_IS_NEWER = 1;
auto constexpr RIGHT_IS_NEWER = -1;
auto constexpr LEFT_EQ_RIGHT = 0;

/**
 * @brief VersionObjectRpm class.
 *
 */
class VersionObjectRpm final : public IVersionObject
{
private:
    static std::regex m_parserRegex;
    uint32_t m_epoch;
    std::string m_version;
    std::string m_release;

    /**
     * @brief Compares two version strings following RPM version comparison rules.
     *
     * This function compares two version strings to determine which version is newer, using comparison rules that
     * mirror those used by RPM. This ensures compatibility with standard RPM package versioning. The comparison process
     * involves several steps to accurately compare version strings that may include alphanumeric characters and tildes
     * (~).
     *
     * The process begins by checking for string equality. If both version strings are identical, they are considered
     * equal. If not, each string is converted into a list of characters for a detailed comparison.
     *
     * The comparison involves the following steps:
     * - First, any leading characters that are not alphanumeric and not tildes (~) are trimmed from both character
     * lists.
     * - Next, leading tildes (~) are removed. The presence of a tilde at the beginning of a version indicates that the
     * version should be considered older than versions without a tilde, even if numerically larger. Therefore, if one
     * version starts with a tilde and the other does not, the version without the tilde is considered newer.
     * - The comparison then proceeds by popping and comparing consecutive blocks of digits or letters from the start of
     * each list. If a difference is found, the comparison result of these blocks is returned immediately.
     * - If all characters are compared without finding a difference, the comparison concludes by examining the lengths
     * of any remaining characters in the lists. A version with remaining characters is considered newer, unless those
     * characters begin with a tilde, in which case it is considered older. This step accounts for scenarios where one
     * version string has been entirely consumed, leaving characters in the other, such as when comparing "1.05b" to
     * "1.05".
     *
     * @param leftVer The left-hand side version string to compare.
     * @param rightVer The right-hand side version string to compare.
     * @return Returns LEFT_EQ_RIGHT if `leftVer` is considered newer, RIGHT_IS_NEWER if `rightVer` is newer, or
     * LEFT_EQ_RIGHT if both versions are considered equal.
     */
    int compareVersions(const std::string& leftVer, const std::string& rightVer) const
    {
        /* easy comparison to see if versions are identical */
        if (leftVer == rightVer)
        {
            return LEFT_EQ_RIGHT;
        }

        char* lhsStrAux = const_cast<char*>(leftVer.c_str());
        char* rhsStrAux = const_cast<char*>(rightVer.c_str());
        char* auxOne = lhsStrAux;
        char* auxTwo = rhsStrAux;
        char auxChrOne, auxChrTwo;
        int isNumber;

        /* loop through each version segment of lhsStrAux and rhsStrAux and compare them */
        while (*auxOne && *auxTwo)
        {
            while (*auxOne && !std::isalnum(*auxOne))
            {
                auxOne++;
            }
            while (*auxTwo && !std::isalnum(*auxTwo))
            {
                auxTwo++;
            }

            /* If we ran to the end of either, we are finished with the loop */
            if (!(*auxOne && *auxTwo))
            {
                break;
            }

            lhsStrAux = auxOne;
            rhsStrAux = auxTwo;

            /* grab first completely alpha or completely numeric segment */
            /* leave one and two pointing to the start of the alpha or numeric */
            /* segment and walk lhsStrAux and rhsStrAux to end of segment */
            if (std::isdigit(*lhsStrAux))
            {
                while (*lhsStrAux && std::isdigit(*lhsStrAux)) lhsStrAux++;
                while (*rhsStrAux && std::isdigit(*rhsStrAux)) rhsStrAux++;
                isNumber = 1;
            }
            else
            {
                while (*lhsStrAux && std::isalpha(*lhsStrAux)) lhsStrAux++;
                while (*rhsStrAux && std::isalpha(*rhsStrAux)) rhsStrAux++;
                isNumber = 0;
            }

            auxChrOne = *lhsStrAux;
            *lhsStrAux = '\0';
            auxChrTwo = *rhsStrAux;
            *rhsStrAux = '\0';

            if (auxOne == lhsStrAux)
            {
                return RIGHT_IS_NEWER;
            }
            if (auxTwo == rhsStrAux)
            {
                return (isNumber ? LEFT_IS_NEWER : RIGHT_IS_NEWER);
            }

            if (isNumber)
            {
                while (*auxOne == '0')
                {
                    auxOne++;
                }

                while (*auxTwo == '0')
                {
                    auxTwo++;
                }

                if (std::strlen(auxOne) > std::strlen(auxTwo))
                {
                    return LEFT_IS_NEWER;
                }

                if (std::strlen(auxTwo) > std::strlen(auxOne))
                {
                    return RIGHT_IS_NEWER;
                }
            }

            auto resultCmp = std::strcmp(auxOne, auxTwo);
            if (resultCmp)
            {
                return (resultCmp < 1 ? RIGHT_IS_NEWER : LEFT_IS_NEWER);
            }

            *lhsStrAux = auxChrOne;
            auxOne = lhsStrAux;
            *rhsStrAux = auxChrTwo;
            auxTwo = rhsStrAux;
        }

        /* this catches the case where all numeric and alpha segments have */
        /* compared identically but the segment sepparating characters were */
        if ((!*auxOne) && (!*auxTwo))
        {
            return LEFT_EQ_RIGHT;
        }

        /* whichever version still has characters left over wins */
        if (!*auxOne)
        {
            return RIGHT_IS_NEWER;
        }
        else
        {
            return LEFT_IS_NEWER;
        }
    }

    /**
     *  Compare two EVR values to determine which is newer
     *
     *  This method compares the epoch, version, and release of the
     *  provided package strings, assuming that epoch is 0 if not provided.
     *  Comparison is performed on the epoch, then the version, and then
     *  the release. If at any point a non-equality is found, the result is
     *  returned without any remaining comparisons being performed (e.g. if
     *  the epochs of the packages differ, the versions are releases are
     *  not compared).
     *
     * @see rpmdev-vercmp(1)
     *
     * @param rRpmVersion The second RPM version.
     *
     * @retval 0 If a and b are equal.
     * @retval <0 If a is smaller than b.
     * @retval >0 If a is greater than b.
     */
    int compareRpmVersion(const uint32_t rEpoch, const std::string& rVersion, const std::string& rRelease) const
    {
        // Compare epochs
        if (m_epoch != rEpoch)
        {
            return m_epoch < rEpoch ? RIGHT_IS_NEWER : LEFT_IS_NEWER;
        }

        // If epochs are equal, compare versions.
        auto verComp = compareVersions(m_version, rVersion);

        if (verComp != LEFT_EQ_RIGHT)
        {
            return verComp;
        }

        // If versions are equal, compare releases.
        return compareVersions(m_release, rRelease);
    }

public:
    /**
     * @brief Static method to match a version string to a Rpm object.
     *
     * @param version version string to match.
     * @param output Rpm object to store the result.
     * @return true/false according to match condition.
     */
    static bool match(const std::string& version, Rpm& output)
    {
        std::smatch parserMatches;
        if ((std::regex_search(version, parserMatches, m_parserRegex)) && (parserMatches.size() == 4))
        {
            output.epoch = parserMatches[1].str().empty() ? 0 : std::stoi(parserMatches[1].str());
            output.version = parserMatches[2].str();
            output.release = parserMatches[3].str();
            return true;
        }
        else
        {
            return false;
        }
    }
    /**
     * @brief Constructor.
     *
     * @param version version SemVer object.
     */
    explicit VersionObjectRpm(const Rpm& version)
        : m_epoch(version.epoch)
        , m_version(version.version)
        , m_release(version.release)
    {
    }
    // LCOV_EXCL_START
    ~VersionObjectRpm() override = default;
    // LCOV_EXCL_STOP

    /**
     * @brief Returns the VersionObjectType of this class.
     *
     * @return VersionObjectType.
     */
    VersionObjectType getType() override
    {
        return VersionObjectType::RPM;
    }

    /**
     * @brief Comparison operator ==.
     *
     * @param b comparison rhs object.
     * @return true/false according to equality condition.
     */
    bool operator==(const IVersionObject& b) const override
    {
        const auto* pB = dynamic_cast<const VersionObjectRpm*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }

        return compareRpmVersion(pB->m_epoch, pB->m_version, pB->m_release) == 0;
    }

    /**
     * @brief Comparison operator <.
     *
     * @param b comparison rhs object.
     * @return true/false according to less than condition.
     */
    bool operator<(const IVersionObject& b) const override
    {
        const auto* pB = dynamic_cast<const VersionObjectRpm*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        return compareRpmVersion(pB->m_epoch, pB->m_version, pB->m_release) == RIGHT_IS_NEWER;
    }
};

#endif // _VERSION_OBJECT_RPM_HPP
